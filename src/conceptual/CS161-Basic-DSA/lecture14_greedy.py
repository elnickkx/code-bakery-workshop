# -*- coding: utf-8 -*-
"""lecture14_greedy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/stanford-cs161/winter2025-extra/blob/colab/lecture14_greedy.ipynb

**Attribution:** These notebooks were originally developed by Mary Wotters and have possibly been modified by Nima Anari and Moses Charikar. Please direct any concerns to Nima and Moses.

# Lecture 14: Greedy algorithms

## Activity selection

### Greedy algorithm for selection.

Here's a simple greedy algorithm for activity selection.
"""

# activities are sorted by end time
def greedyActivitySelection(activities):
    schedule = []
    currentTime = activities[0][0] - 1 # start before any of the activities start.
    for i in range(len(activities)):
        start, finish = activities[i]
        if start > currentTime:
            schedule.append(i)
            currentTime = finish
    return schedule

# Sanity check.
#
# 123456789012345
# ####
#  ####
#   ####
#     ###
#   ######
#      ####
#        ###
#         ###
#     ########
#      ########
#        #######
#             ###

# Solution should be:
# ####               (1,4)
#     ###            (5,7)
#        ###         (8,10)
#             ###   (13,15)

activities = [  [1,4],[2,5],[3,6],[5,7],[3,8],[6,9],[8,10],[9,11],[5,12],[6,13],[8,14],[13,15] ]
activityList = greedyActivitySelection(activities)
print("Solution:")
for act in activityList:
    print(activities[act])

"""### Here's what we'd do if we tried the DP approach instead.

Step 1: identify a recursive relationship and write a top-down DP to find the optimal number of activities.
"""

# activities are sorted by end time
def maxNumActivities(activities, i, A):
    if A[i] != None:
        return A[i]
    istart,ifinish = activities[i]
    # this is not a good way to implement this, but the point of this way of writing it is not the implementation
    for k in range(len(activities)):
        start, finish = activities[k]
        if start > ifinish:
            valk = maxNumActivities(activities,k,A)
            A[i] = valk + 1
            return A[i]
    A[i] = 0 # there are no more activities here
    return A[i]

"""Step 2: Now let's modify the above to return not just the length but the actual value:"""

# activities are sorted by end time
def getSchedule(activities, i, A, Next):
    if A[i] != None:
        return A[i]
    istart,ifinish = activities[i]
    # this is not a good way to implement this, but the point of this way of writing it is not the implementation
    for k in range(len(activities)):
        start, finish = activities[k]
        if start > ifinish:
            Next[i] = k # after i, do k
            valk = getSchedule(activities,k,A,Next)
            A[i] = valk + 1
            return A[i]
    A[i] = 0 # there are no more activities here
    return A[i]

def findBestSchedule(activities):
    A = [ None for i in range(len(activities)) ]
    Next = [ None for i in range(len(activities)) ]
    getSchedule(activities,0, A, Next)
    current = 0
    schedule = []
    while True:
        current = Next[current]
        if current == None:
            break
        schedule.append(current)
    return schedule

"""Sanity-check:"""

activities = [ [-1,0], [1,4],[2,5],[3,6],[5,7],[3,8],[6,9],[8,10],[9,11],[5,12],[6,13],[8,14],[13,15] ]
activityList = findBestSchedule(activities)
for act in activityList:
    print(activities[act])

"""But what is this actually doing?  Let's do it again with some print statements."""

# activities are sorted by end time
def getSchedule(activities, i, A, Next):
    if A[i] != None:
        return A[i]
    istart,ifinish = activities[i]
    # this is not a good way to implement this, but the point of this way of writing it is not the implementation
    for k in range(len(activities)):
        start, finish = activities[k]
        if start > ifinish:
            Next[i] = k # after i, do k
            print("After activity", activities[i], "I am adding the next thing which is", activities[k])
            valk = getSchedule(activities,k,A,Next)
            A[i] = valk + 1
            return A[i]
    A[i] = 0 # there are no more activities here
    return A[i]
def findBestSchedule(activities):
    A = [ None for i in range(len(activities)) ]
    Next = [ None for i in range(len(activities)) ]
    getSchedule(activities,0, A, Next)
    current = 0
    schedule = []
    while True:
        current = Next[current]
        if current == None:
            break
        schedule.append(current)
    return schedule

activities = [ [-1,0], [1,4],[2,5],[3,6],[5,7],[3,8],[6,9],[8,10],[9,11],[5,12],[6,13],[8,14],[13,15] ]
activityList = findBestSchedule(activities)
print("---\n Solution:")
for act in activityList:
    print(activities[act])

