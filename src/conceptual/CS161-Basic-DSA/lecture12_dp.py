# -*- coding: utf-8 -*-
"""lecture12_dp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/stanford-cs161/winter2025-extra/blob/colab/lecture12_dp.ipynb

**Attribution:** These notebooks were originally developed by Mary Wotters and have possibly been modified by Nima Anari and Moses Charikar. Please direct any concerns to Nima and Moses.

# Lecture 12: Dynamic Programming

In lecture we'll also talk about the Floyd-Warshall and Bellman-Ford algorithms.  In this notebook we'll introduce the benefits of dynamic programming by considering the simple problem of computing Fibonacci numbers.
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import time
# %matplotlib inline

"""Here is one way to compute the Fibonacci numbers:"""

def Fibonacci(n):
    if n == 0 or n == 1:
        return 1
    return Fibonacci(n-1) + Fibonacci(n-2)

for n in range(10):
    print(Fibonacci(n))

def computeSomeVals(myFn, Ns = range(10,100,10), numTrials=3):
    nValues = []
    tValues = []
    for n in Ns:
        # run myFn several times and average to get a decent idea.
        runtime = 0
        for t in range(numTrials):
            start = time.time()
            myFn(n)
            end = time.time()
            runtime += (end - start) * 1000 # measure in milliseconds
        runtime = runtime/numTrials
        nValues.append(n)
        tValues.append(runtime)
    return nValues, tValues

nVals = range(1,30)
nVals, tVals = computeSomeVals(Fibonacci, nVals)

plt.plot(nVals, tVals, color="blue", label="Naive Fibonacci")
plt.xlabel("n")
plt.ylabel("Time(ms)")
plt.legend()
plt.title("Computing Fibonacci Numbers")

def fasterFibonacci(n):
    F = [1 for i in range(n+1)]
    for i in range(2,n+1):
        F[i] = F[i-1] + F[i-2]
    return F[n]

for n in range(10):
    print(Fibonacci(n))

nValsFast = range(1,2000,10)
nValsFast, tValsFast = computeSomeVals(fasterFibonacci, nValsFast,numTrials=50)

plt.plot(nVals, tVals, color="blue", label="Naive Fibonacci")
plt.plot(nValsFast, tValsFast, "--", color="red", label="faster Fibonacci")
plt.xlabel("n")
plt.ylabel("Time(ms)")
plt.legend()
plt.ylim([0,tValsFast[-1]])
plt.title("Computing Fibonacci Numbers")

def Fibonacci_topdown(n,F):
    if F[n] != None:
        return F[n]
    F[n] = Fibonacci_topdown(n-1,F) + Fibonacci_topdown(n-2,F)
    return F[n]

for n in range(10):
    print(Fibonacci_topdown(n, [1,1] + [None for i in range(n-1)]))

nValsTD = range(1,2000,10)
nValsTD, tValsTD = computeSomeVals(fasterFibonacci, nValsTD,numTrials=50)

plt.plot(nVals, tVals, color="blue", label="Naive Fibonacci")
plt.plot(nValsFast, tValsFast, "--", color="red", label="faster Fibonacci, bottom-up")
plt.plot(nValsTD, tValsTD, ":", color="green", label="faster Fibonacci, top-down")
plt.xlabel("n")
plt.ylabel("Time(ms)")
plt.legend()
plt.ylim([0,tValsFast[-1]])
plt.title("Computing Fibonacci Numbers")

"""# Here's a puzzle:

Our code looks like it has runtime O(n).  But if we go out far enough it looks like it's curving up.  What's going on?  (You'll see this on your HW)
"""

nValsFast = list(range(1,100,10)) + list(range(100,1000,100)) + list(range(1000,10000,500)) + list(range(10000,50000,5000))
nValsFast, tValsFast = computeSomeVals(fasterFibonacci, nValsFast,numTrials=20)

plt.plot(nValsFast, tValsFast, "--", color="red", label="faster Fibonacci (bottom-up)")
plt.xlabel("n")
plt.ylabel("Time(ms)")
plt.legend()
plt.ylim([0,tValsFast[-1]])
plt.title("Computing Fibonacci Numbers")
plt.show()

def squareMat(a,b,c,d):
    return ( a**2 + b*c, a*b + b*d , c*a + d*c , c*b + d**2 )
def makePower(t):
    a = 0
    b = 1
    c = 1
    d = 1
    for i in range(t):
        a,b,c,d = squareMat(a,b,c,d)
    return a + b

for t in range(8):
    print(t, fasterFibonacci(2**t), makePower(t))

fakeNVals = [x for x in range(17)]
nValsFaster, tValsFaster = computeSomeVals(makePower, fakeNVals,numTrials=50)
nValsFaster = [2**x for x in range(17)]

plt.plot(nValsFast, tValsFast, "--", color="red", label="faster Fibonacci (bottom-up)")
plt.plot(nValsFaster, tValsFaster, "-", color="blue", label="real faster Fibonacci")
plt.xlabel("n")
plt.ylabel("Time(ms)")
plt.legend()
plt.ylim([0,40])
plt.title("Computing Fibonacci Numbers")
plt.show()





