# -*- coding: utf-8 -*-
"""lecture15_mst.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/stanford-cs161/winter2025-extra/blob/colab/lecture15_mst.ipynb

**Attribution:** These notebooks were originally developed by Mary Wotters and have possibly been modified by Nima Anari and Moses Charikar. Please direct any concerns to Nima and Moses.
"""

# This part downloads needed auxiliary files to Google Colab
! curl https://stanford-cs161.github.io/winter2025-extra/lecture15_mst-aux.zip > lecture15_mst-aux.zip && unzip -o lecture15_mst-aux.zip

"""# Minimum Spanning Trees"""

# Commented out IPython magic to ensure Python compatibility.
from graphStuff import *
import heapdict as heapdict # you will need to install heapdict to use this
import time
import matplotlib
import numpy as np
from random import random
from random import choice
import matplotlib.pyplot as plt
# %matplotlib inline

"""First, let's implement the "slowPrim" greedy algorithm that we saw in class"""

# G is a connected CS161Graph, s is a vertex to start at.
def slowPrim(G,s):
    # first, find the lightest edge leaving s
    bestWt = np.inf
    bestu = None
    for u,wt in s.getOutNeighborsWithWeights():
        if wt < bestWt:
            bestWt = wt
            bestu = u
    MST = [ (s,bestu) ]
    verticesVisited = [s,bestu]
    while len(verticesVisited) < len(G.vertices): # danger! this will loop forever if the graph isn't connected...
        # find the lightest edge (x,v) so that x has been visited and v hasn't.
        bestWt = np.inf
        bestv = None
        bestx = None
        for x in verticesVisited:
            for v,wt in x.getOutNeighborsWithWeights():
                if v in verticesVisited:
                    continue
                if wt < bestWt:
                    bestWt = wt
                    bestv = v
                    bestx = x
        MST.append((bestx,bestv))
        verticesVisited.append(bestv)
    return MST

"""(Some quick sanity checks)"""

# As a sanity check, let's make a random graph
def makeRandomGraph(n,p):
    G = CS161Graph()
    for i in range(n):
        G.addVertex(CS161Vertex(i))
    for i in range(n):
        for j in range(i+1,n):
            if random() < p:
                G.addBiEdge(G.vertices[i], G.vertices[j], wt=random())
    return G

# this is a complete graph with random edge weights
G = makeRandomGraph(4,1)
print(G)

# do we get a MST?  (Seems ok)
T = slowPrim(G,G.vertices[0])
for x,y in T:
    print(x,y)

"""### Now let's implement prim's algorithm for real:"""

# Not gonna lie, totally copied-and-pasted the Dijkstra code from Lecture 11 as a starting point -- they are quite similar!
def prim(G,w):
    for v in G.vertices:
        v.estD = np.inf
    w.estD = 0
    MST = []
    unvisitedVertices = heapdict.heapdict()
    for v in G.vertices:
        unvisitedVertices[v] = v.estD
    while len(unvisitedVertices) > 0:
        # find the u with the minimum estD, using the heap
        u, dist = unvisitedVertices.popitem()
        if u.estD == np.inf:
            # then there is nothing more that I can reach; this shouldn't happen if the graph is connected
            return "Graph disconnected :("
        # add u to the MST
        if u.parent != None:  # don't do it for the first vertex
            MST.append((u.parent,u))
        # update u's neighbors
        for v,wt in u.getOutNeighborsWithWeights():
            if v in unvisitedVertices:
                if wt < v.estD:
                    v.estD = wt
                    unvisitedVertices[v] =  wt #update the key in the heapdict
                    v.parent = u # v points to u now
    return MST

# make sure it does the same thing as slowPrim
G = makeRandomGraph(14,1)
Tprim = prim(G,G.vertices[0])
Tslow = slowPrim(G,G.vertices[0])

for i in range(len(Tprim)):
    x,y = Tprim[i]
    a,b = Tslow[i]
    print(x,y ,"\t vs \t", a, b)


def areEqual(A,B):
    if len(A) != len(B):
        return False
    for a in A:
        if a not in B:
            return False
    return True

if areEqual(Tprim,Tslow):
    print("It worked!")

# generate a bunch of random graphs and run an alg to compute shortest paths (implicitly)
def runTrials(myFn, nVals, pFn, numTrials=25):
    nValues = []
    tValues = []
    for n in nVals:
        # run myFn several times and average to get a decent idea.
        runtime = 0
        for t in range(numTrials):
            G = makeRandomGraph(n, pFn(n))  #Random graph on n vertices with about pn^2 edges
            start = time.time()
            myFn( G, G.vertices[0])
            end = time.time()
            runtime += (end - start) * 1000 # measure in milliseconds
        runtime = runtime/numTrials
        nValues.append(n)
        tValues.append(runtime)
    return nValues, tValues

def smallFrac(n):
    return float(10/n)
nValues = [10,50,100,150,200]
nSlowPrim, tSlowPrim = runTrials(slowPrim, nValues,smallFrac)
nPrim, tPrim = runTrials(prim, nValues,smallFrac)

plt.plot(nSlowPrim, tSlowPrim, color="red", label="slowPrim")
plt.plot(nPrim, tPrim, "-.", color="blue", label="prim with a heap")
plt.xlabel("n")
plt.ylabel("Time(ms)")
plt.legend()
plt.title("Shortest paths on a graph with n vertices and about 10n edges")
plt.show()

